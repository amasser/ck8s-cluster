apiVersion: templates.gatekeeper.sh/v1alpha1
kind: ConstraintTemplate
metadata:
  name: k8spodcoveredbyresources
spec:
  crd:
    spec:
      names:
        kind: K8sPodCoveredbyResource
        listKind: K8sPodCoveredByResourceList
        plural: k8spodcoveredbyresources
        singular: k8spodcoveredbyresource
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          properties:
            resource:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8stest


        operations = {"UPDATE", "CREATE"}
        
        labels = res {
            input.review.kind.group == "apps"
            res := input.review.object.spec.template.metadata.labels
        }

        labels = res {
            input.review.kind.kind == "Pod"
            res := input.review.object.metadata.labels
        }

        selectors = res {
            resource := input.constraint.spec.parameters.resource
            resource == "NetworkPolicy"
            namespace := input.review.object.metadata.namespace
            res := [x | x := data.inventory.namespace[namespace][_][resource][_].spec.podSelector]
        }

        selectors = res {
            resource := input.constraint.spec.parameters.resource
            resource == "PodDisruptionBudget"
            namespace := input.review.object.metadata.namespace
            res := [x | x := data.inventory.namespace[namespace][_][resource][_].spec.selector]
        }

        deny[{"msg": msg, "details": {"Bindingghghgh": "name"}}] {
          
            operations[input.review.operation] 
            namespace := input.review.object.metadata.namespace
            
            res = [x | x := allChecks(selectors[_])]
            all(res) #all resources failed to match
            msg := sprintf("Test2 error, resource: %v, labels: %v, found in %v %v (namespace %v)", [res, input.constraint.spec.parameters.resource, input.review.kind.kind, input.review.object.metadata.name, namespace])
        }

        #Check one resource, returns true if it does not match
        allChecks(selector) = res {
            r1 := matchLabelsMissingKeys(selector)
            r2 := any(matchLabelsValues(selector))
            r3 := matchExpressionsExists(selector)
            r4 := matchExpressionsDoesNotExist(selector)
            r5 := any(matchExpressionsIn(selector))
            r6 := any(matchExpressionsNotIn(selector))
            #return true if any part of the resource does not match
            res := any({r1, r2, r3, r4, r5, r6})
        }

        matchLabelsMissingKeys(selector) = res {
            res3 := {key | selector.matchLabels[key]}
            res4 := {key | labels[key]}
            res := count(res3 - res4) != 0
        }

        matchLabelsValues(selector) = res {
            res := [x | 
                labels[key1] != selector.matchLabels[key3];
                x := key1 == key3]
        }

        matchExpressionsExists(selector) = res {
            keys := { key | 
                selector.matchExpressions[i].operator == "Exists"
                key := selector.matchExpressions[i].key}
            inputKeys := {key | labels[key]}
            res := count(keys - inputKeys) != 0
        }

        matchExpressionsDoesNotExist(selector) = res {
            keys := { key | 
                selector.matchExpressions[i].operator == "DoesNotExist"
                key := selector.matchExpressions[i].key}
            inputKeys := {key | labels[key]}
            res := count(keys & inputKeys) != 0
        }

        matchExpressionsIn(selector) = res {
            res := [ x | 
                selector.matchExpressions[i].operator == "In"
                key := selector.matchExpressions[i].key
                x := false == any([y | y := labels[key] == selector.matchExpressions[i].values[_]])]
        }

        matchExpressionsNotIn(selector) = res {
            res := [ x | 
                selector.matchExpressions[i].operator == "NotIn"
                key := selector.matchExpressions[i].key
                x := any([y | y := labels[key] == selector.matchExpressions[i].values[_]])]
        }